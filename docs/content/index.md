<a name="_response_parsers"></a>
# \_response\_parsers

helper functions for parsing response text from the JPL Horizons CGI.
these functions are intended to be called by LHorizon methods and should
generally not be called directly.

<a name="_response_parsers.make_lhorizon_dataframe"></a>
#### make\_lhorizon\_dataframe

```python
make_lhorizon_dataframe(jpl_response: str, topocentric_target: bool = False) -> pd.DataFrame
```

make a DataFrame from Horizons CGI response text.

<a name="_response_parsers.clean_up_vectors_series"></a>
#### clean\_up\_vectors\_series

```python
clean_up_vectors_series(pattern: str, series: Array) -> pd.Series
```

regularize units, format text, and parse dates in a VECTORS table column

<a name="_response_parsers.clean_up_observer_series"></a>
#### clean\_up\_observer\_series

```python
clean_up_observer_series(pattern: str, series: Array) -> Optional[pd.Series]
```

regularize units, format text, and parse dates in an OBSERVER table column

<a name="_response_parsers.clean_up_series"></a>
#### clean\_up\_series

```python
clean_up_series(query_type: str, pattern: str, series: Array) -> pd.Series
```

dispatch function for Horizons column cleanup functions

<a name="_response_parsers.polish_lhorizon_dataframe"></a>
#### polish\_lhorizon\_dataframe

```python
polish_lhorizon_dataframe(horizon_frame: pd.DataFrame, query_type: str) -> pd.DataFrame
```

make a nicely-formatted table from a dataframe generated by
make_lhorizon_dataframe. make tractable column names. also convert
distance units from AU or km to m and arcseconds to degrees.

<a name="__init__"></a>
# \_\_init\_\_

<a name="solutions"></a>
# solutions

functionality for solving body-intersection problems. used by
`lhorizon.targeter`. currently contains only ray-sphere intersection solutions
but could also sensibly contain expressions for bodies of different shapes.

<a name="solutions.ray_sphere_equations"></a>
#### ray\_sphere\_equations

```python
ray_sphere_equations(radius: float) -> list[sp.Eq]
```

generate a simple system of equations for intersections between
a ray with origin at (0, 0, 0) and direction vector [x, y, z]
and a sphere with radius == 'radius' and center (mx, my, mz).

<a name="solutions.get_ray_sphere_solution"></a>
#### get\_ray\_sphere\_solution

```python
get_ray_sphere_solution(radius: float, farside: bool = False) -> tuple[sp.Expr]
```

produce a solution to the generalized ray-sphere equation for a body of
radius `radius`. by default, take the nearside solution. this produces a
tuple of sympy expressions objects, which are fairly slow to evaluate;
unless you are planning to further manipulate them, you would probably
rather call make_ray_sphere_lambdas().

<a name="solutions.lambdify_system"></a>
#### lambdify\_system

```python
lambdify_system(expressions: Sequence[sp.Expr], expression_names: Sequence[str], variables: Sequence[sp.Symbol]) -> dict[str, Callable]
```

returns a dict of functions that substitute the symbols in 'variables'
into the expressions in 'expressions'. 'expression_names' serve as the
keys of the dict.

<a name="solutions.make_ray_sphere_lambdas"></a>
#### make\_ray\_sphere\_lambdas

```python
make_ray_sphere_lambdas(radius: float, farside=False)
```

produce a dict of functions that return solutions for the ray-sphere
equation for a sphere of radius `radius`.

<a name="config"></a>
# config

configuration options for `lhorizon`

OBSERVER_QUANTITIES: default Horizons QUANTITIES columns for OBSERVER queries
VECTORS_QUANTITIES: timeout for connecting to jpl server
TIMEOUT: timeout in seconds for JPL
HORIZONS_SERVER: address of Horizons CGI gateway
DEFAULT_HEADERS: default headers for Horizons requests
TABLE_PATTERNS: tables of regexes used to match Horizons fields and the
    arguably more-readable column names we assign them to

<a name="_request_formatters"></a>
# \_request\_formatters

formatters to translate various parameters and options into URL parameters
that can be parsed by JPL Horizons' CGI. These are mostly intended to be used
by LHorizon methods and should probably not be called directly.

<a name="_request_formatters.format_geodetic_origin"></a>
#### format\_geodetic\_origin

```python
format_geodetic_origin(location: Mapping) -> dict
```

creates dict of URL parameters for a geodetic coordinate origin

<a name="_request_formatters.format_geodetic_target"></a>
#### format\_geodetic\_target

```python
format_geodetic_target(location: Mapping) -> str
```

creates command string for a geodetic target

<a name="_request_formatters.format_epoch_params"></a>
#### format\_epoch\_params

```python
format_epoch_params(epochs: Union[Sequence, Mapping]) -> dict
```

creates dict of URL parameters from epochs

<a name="_request_formatters.make_commandline"></a>
#### make\_commandline

```python
make_commandline(target: Union[str, int, Mapping], closest_apparition: Union[bool, str], no_fragments: bool)
```

makes 'primary' command string for Horizons CGI request'

<a name="_request_formatters.assemble_request_params"></a>
#### assemble\_request\_params

```python
assemble_request_params(commandline: str, query_type: str, extra_precision: bool, max_hour_angle: float, quantities: str, refraction: bool, refsystem: str, solar_elongation: Sequence[int]) -> dict[str]
```

final-stage assembler for Horizons CGI URL parameters

<a name="base"></a>
# base

This is the base module for `lhorizon`. It implements a class, `LHorizon`,
used to query the `JPL Horizons <https://ssd.jpl.nasa.gov/horizons.cgi>`
solar system ephemerides service.

<a name="base.LHorizon"></a>
## LHorizon Objects

```python
class LHorizon()
```

JPL HORIZONS interface object, the core class of `lhorizon`.

## Parameters

* target : str or int, optional
    * Name, number, or designation of the object to be queried. the Moon
    is used if no target is passed. Arbitrary topocentric coordinates
    can also be provided in a dict, like:
    ```python
    {
        'lon': longitude in deg,
        'lat': latitude in deg (North positive, South negative),
        'elevation': elevation in km above the reference ellipsoid,
        ['body': Horizons body ID of the central body; optional;
        Earth is used if it is not provided.]
    }.
    ```
    Horizons must possess a rotational model and reference ellipsoid
    for the central body in order to process topocentric queries --
    don't expect this to work with artificial satellites or most small
    bodies, for instance.  Also note that Horizons always treats
    west-longitude as positive for prograde bodies and east-longitude
    as positive for retrograde bodies, with the very notable
    exceptions of the Earth, Moon, and Sun; despite the fact that they
    are prograde, it treats east-longitude as positive on these three
    bodies.
origin : int, str, or dict, optional
    Coordinate origin (representing central body or observer location).
    Uses the same codes as JPL Horizons -- in some cases, text will
    work, in some cases it will not. If no location is provided,
    Earth's center is used. Arbitrary topocentic coordinates can also
    be given as a dict, in the same format as the target parameter.
epochs : dict[str, str] or Sequence[str, float, dt.datetime], optional
    Either a scalar in any astropy.time - parsable format,
    a list of epochs in jd, iso, or dt format, or a dict
    defining a range of times and dates. Timescale is UTC for OBSERVER
    queries and TDB for VECTORS queries. If no epochs are provided,
    the current time is used. Scalars or range dictionaries are
    preferred over lists, as they tend to be processed more easily by
    Horizons. The range dictionary format is:
    {
        ``'start'``:'YYYY-MM-DD [HH:MM:SS.fff]',
        ``'stop'``:'YYYY-MM-DD [HH:MM:SS.fff]',
        ``'step'``:'n[y|d|h|m]'
    }
    If no units are provided for step, Horizons evenly divides the
    period between start and stop into n intervals.
session: requests.Session, optional
    session object for optimizing API calls. A new session is generated
    if one is not passed.
allow_long_queries: bool, optional
    if True, allows long (>2000 character) URLs to be used to query
    JPL Horizons. These will often be truncated serverside, resulting
    in unexpected output, and so are not allowed by default.
query_options: dict, optional
    additional Horizons query options. See documentation for a list of
    supported options.

<a name="base.LHorizon.dataframe"></a>
#### dataframe

```python
 | dataframe() -> pd.DataFrame
```

return a DataFrame containing minimally-formatted response text from
JPL Horizons -- column names and quantities as sent, with almost no
changes but whitespace stripping.

this function triggers a query to JPL Horizons if a query has not yet
been sent. Otherwise, it uses the cached response.

<a name="base.LHorizon.table"></a>
#### table

```python
 | table() -> pd.DataFrame
```

return a DataFrame with additional formatting. Regularizes column
names, casts times to datetime, attempts to regularize units. All
contents should be in m-s. JPL Horizons has an extremely wide range of
special-case response formatting, so if these heuristics prune
necessary columns or appear to perform incorrect conversions, fall
back to LHorizon.dataframe().

this function triggers a query to JPL Horizons if a query has not yet
been sent. Otherwise, it uses the cached response.

<a name="base.LHorizon.check_queried"></a>
#### check\_queried

```python
 | check_queried() -> bool
```

determine whether this LHorizon has been queried with its currently-
formatted request. Note that if you manually change the request
parameters of a queried LHorizon and do not subsequently call
LHorizon.prepare_request(), LHorizon.check_queried() will
'incorrectly' return True.

<a name="base.LHorizon.query"></a>
#### query

```python
 | query(refetch: bool = False) -> None
```

send this LHorizon's currently-formatted request to JPL HORIZONS and
update this LHorizon's response attribute. if we have already fetched
with identical parameters, don't fetch again unless explicitly told to.

<a name="base.LHorizon.prepare_request"></a>
#### prepare\_request

```python
 | prepare_request()
```

Prepare request using active session and parameters. this is called
automatically by LHorizon.__init__(), but can also be called after
query parameters or request have been manually altered.

<a name="base.LHorizon.__str__"></a>
#### \_\_str\_\_

```python
 | __str__()
```

String representation of LHorizon object instance

<a name="base.LHorizon.__repr__"></a>
#### \_\_repr\_\_

```python
 | __repr__()
```

String representation of LHorizon object instance

<a name="target"></a>
# target

<a name="target.find_intersections"></a>
#### find\_intersections

```python
find_intersections(solutions: Mapping[Callable], ray_direction: Array, target_center: Array) -> dict
```

find intersections between ray_direction and target_center given a mapping
of functions (output of solutions.make_ray_sphere_lambdas(), for instance)

<a name="target.array_reference_shift"></a>
#### array\_reference\_shift

```python
array_reference_shift(positions: Array, time_series: Sequence, origin: str, destination: str, wide: bool = False)
```

using SPICE, transform an array of position vectors from origin (frame) to
destination (frame) at times in time_series. also computes spherical
representation of these coordinates. time_series must be in et (seconds
since J2000)

<a name="target.Targeter"></a>
## Targeter Objects

```python
class Targeter()
```

<a name="target.Targeter.__init__"></a>
#### \_\_init\_\_

```python
 | __init__(target: Ephemeris, solutions: Mapping[Callable] = None, target_radius: Optional[float] = None)
```

target: LHorizon instance or dataframe; if a dataframe, must
    have columns named 'ra, dec, dist', 'az, alt, dist', or 'x, y, z'
    if the LHorizon instance is an OBSERVER query, uses ra_app_icrf
    and dec_app_icrf, if VECTORS, uses x/y/z

solutions: mapping of functions that each accept six args -- x1, y1,
    z1, x2, y2, z2 -- and return at least x, y, z position of an
    "intersection" (however defined). for compatibility with other
    functions in this module, should return NaN values for cases in
    which no intersection is found. if this parameter is not passed,
    generates ray-sphere solutions from the passed target radius.

target_radius: used only if no intersection solutions are
    passed; generates a system of ray-sphere intersection solutions for
    a target body of this radius.

<a name="target.Targeter.find_targets"></a>
#### find\_targets

```python
 | find_targets(pointings: Union[pd.DataFrame, LHorizon]) -> None
```

find targets using pointing vectors in a passed dataframe or lhorizon.
time series must match time series in body ephemeris. stores passed
pointings in self.ephemerides['pointing'] and solutions in
self.ephemerides['topocentric']

note that target center vectors and pointing vectors must be in the
same frame of reference or downstream results will be silly.

if you pass it a set of pointings without a time field, it will assume
that their time field is identical to the time field of
self.ephemerides["body"].

unless you do something extremely fancy in the solver,
the intersections will be 'geometric' quantities and thus reintroduce
some error due to light-time, rotation, aberration, etc. between target
body surface and target body center -- but considerably less error than
if you don't have a corrected vector from origin to target body center.

<a name="target.Targeter.find_target_grid"></a>
#### find\_target\_grid

```python
 | find_target_grid(raveled_meshgrid: pd.DataFrame) -> None
```

finds targets at a single moment in time for a grid of coordinates
expressed as an output of lhorizon_utils.make_raveled_meshgrid().
stores them in self.ephemerides["topocentric"] and the raveled meshgrid
in self.ephemerides["pointing"].

all non-time-releated caveats from Targeter.find_targets() apply.

<a name="target.Targeter.transform_targets_to_body_frame"></a>
#### transform\_targets\_to\_body\_frame

```python
 | transform_targets_to_body_frame(source_frame="j2000", target_frame="j2000")
```

transform targets from source_frame to body_frame. you must initialize
self.ephemerides["topocentric"] using find_targets() or
find_target_grid() before calling this function.

<a name="handlers"></a>
# handlers

This module contains a number of specialized query constructors and related
helper functions for lhorizon.

<a name="handlers.estimate_line_count"></a>
#### estimate\_line\_count

```python
estimate_line_count(horizons_dt: MutableMapping[str, dt.datetime], seconds_per_step: float)
```

estimate the number of lines that will be returned by Horizons for a given
query. Cannot give correct answers for cases in which airmass, hour
angle, or other restrictive options are set. Used by bulk query
constructors to help split large queries across multiple LHorizons.

<a name="handlers.chunk_time"></a>
#### chunk\_time

```python
chunk_time(epochs: MutableMapping, chunksize: int) -> list[dict]
```

chunk time into a series of intervals that will return at most chunksize
lines from Horizons.

<a name="handlers.datetime_from_horizon_epochs"></a>
#### datetime\_from\_horizon\_epochs

```python
datetime_from_horizon_epochs(start: str, stop: str, step: Union[int, str])
```

convert horizon epoch dict to datetime to estimate response length.

<a name="handlers.construct_lhorizon_list"></a>
#### construct\_lhorizon\_list

```python
construct_lhorizon_list(epochs: MutableMapping, target: Union[int, str, MutableMapping] = "301", origin: Union[int, str, MutableMapping] = "500@399", session: Optional[requests.Session] = None, query_type: str = "OBSERVER", query_options: Optional[Mapping] = None, chunksize=85000) -> list[LHorizon]
```

construct a list of LHorizons from a query. Intended for queries that will
return over 90000 lines, which is currently the hard limit of the Horizons
CGI. this function takes most of the same arguments as LHorizon, but
epochs must be specified as a dictionary with times in ISO format.
this function does not support chunking long lists of explicitly-defined
individual epochs. queries of this type are extremely inefficient for the
Horizons backend and delivering many of them in quick succession typically
causes it to tightly throttle the requester.

<a name="handlers.query_all_lhorizons"></a>
#### query\_all\_lhorizons

```python
query_all_lhorizons(lhorizons: Sequence[LHorizon], delay_between=2, delay_retry=8)
```

queries all LHorizons in a passed sequence of LHorizons using a shared
session, carefully closing sockets and pausing between them, regenerating
session and pausing for a longer interval if JPL Horizons rejects a query

<a name="handlers.list_sites"></a>
#### list\_sites

```python
list_sites(center_body: int = 399) -> pd.DataFrame
```

query Horizons for all named sites recognized on the specified body and
format this response as a DataFrame. if no body is specified, uses Earth
(399).

<a name="handlers.list_majorbodies"></a>
#### list\_majorbodies

```python
list_majorbodies() -> pd.DataFrame
```

query Horizons for all currently-recognized major bodies and format the
response into a DataFrame.

<a name="lhorizon_utils"></a>
# lhorizon\_utils

<a name="lhorizon_utils.listify"></a>
#### listify

```python
listify(thing: Any) -> list
```

Always a list, for things that want lists. use with care.

<a name="lhorizon_utils.snorm"></a>
#### snorm

```python
snorm(thing: Any, minimum: float = 0, maximum: float = 1, m0: Optional[float] = None, m1: Optional[float] = None) -> Union[list[float], float]
```

simple min-max scaler. minimum and maximum are the limits of the range of
the returned sequence. m1 and m2 are optional parameters that specify
floor and ceiling values for the input other than its actual minimum and
maximum. If a single value is passed for thing, returns a float;
otherwise, returns a sequence of floats.

<a name="lhorizon_utils.hunt_csv"></a>
#### hunt\_csv

```python
hunt_csv(regex: Pattern, body: str) -> list
```

finds chunk of csv in a larger string defined as regex, splits it,
and returns as list. really useful only for single lines.
worse than StringIO -> numpy or pandas csv reader in other cases.

<a name="lhorizon_utils.dt_to_jd"></a>
#### dt\_to\_jd

```python
dt_to_jd(time: Union[dt.datetime, pd.Series]) -> Union[float, pd.Series]
```

convert passed datetime or Series of datetime to julian day number (jd).
algorithm derived from Julian Date article on scienceworld.wolfram.com,
itself based on Danby, J. M., Fundamentals of Celestial Mechanics

<a name="lhorizon_utils.numeric_columns"></a>
#### numeric\_columns

```python
numeric_columns(data: pd.DataFrame) -> list[str]
```

return a list of all numeric columns of a DataFrame

<a name="lhorizon_utils.produce_jd_series"></a>
#### produce\_jd\_series

```python
produce_jd_series(epochs: Union[Timelike, Sequence[Timelike]]) -> pd.Series
```

convert passed epochs to julian day number (jd). scale is assumed to be
utc. this may of course produce very slightly spurious results for dates
in the future for which leap seconds have not yet been assigned. floats or
floatlike strings will be interpreted as jd and not modified. inputs of
mixed time formats or scales will likely produce undesired behavior.

<a name="lhorizon_utils.time_series_to_et"></a>
#### time\_series\_to\_et

```python
time_series_to_et(time_series)
```

convert time -> 'seconds since J2000' epoch scale preferred by SPICE --
anything pandas

<a name="lhorizon_utils.is_it"></a>
#### is\_it

```python
is_it(*types)
```

partially-evaluated predicate form of isinstance

<a name="lhorizon_utils.sph2cart"></a>
#### sph2cart

```python
sph2cart(lat: Union[float, Array], lon: Union[float, Array], radius: Union[float, Array] = 1, unit: str = "degrees")
```

convert spherical to cartesian coordinates. assumes input is in degrees
by default; pass unit="radians" to specify input in radians. if passed any
arraylike objects, returns a DataFrame, otherwise, returns a tuple of
values.

<a name="lhorizon_utils.cart2sph"></a>
#### cart2sph

```python
cart2sph(x0: Union[float, Array], y0: Union[float, Array], z0: Union[float, Array], unit: str = "degrees") -> Union[pd.DataFrame, tuple]
```

convert cartesian to spherical coordinates. returns degrees by default;
pass unit="radians" to return radians. if passed any arraylike objects,
returns a DataFrame, otherwise, returns a tuple of values.

<a name="lhorizon_utils.hats"></a>
#### hats

```python
hats(vectors: Union[np.ndarray, pd.DataFrame, pd.Series]) -> Union[np.ndarray, pd.DataFrame, pd.Series]
```

convert an array of passed "vectors" (row-wise-stacked sequences of
floats) to unit vectors

<a name="lhorizon_utils.make_raveled_meshgrid"></a>
#### make\_raveled\_meshgrid

```python
make_raveled_meshgrid(axes: Sequence[np.ndarray], axis_names: Optional[Sequence[str, int]] = None)
```

produces a flattened, indexed version of a 'meshgrid' (a cartesian
product of axes standing in for a vector space, conventionally produced
by numpy.meshgrid)

<a name="lhorizon_utils.default_lhorizon_session"></a>
#### default\_lhorizon\_session

```python
default_lhorizon_session() -> requests.Session
```

returns a requests.Session object with default `lhorizon` options

<a name="kernels"></a>
# kernels

<a name="kernels.load"></a>
# kernels.load

<a name="kernels.load.load_metakernel"></a>
#### load\_metakernel

```python
load_metakernel()
```

it's impossible to accurately 'target' paths in a flexible way inside a
SPICE metakernel, so we do it here
TODO: or we could write an extended furnsh() replacement that dynamically
 assembled a metakernel. maybe.

